# 计算机原、反、补码

​        计算机中的有符号数有三种表示方法，即原码 、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同 。在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理 



真值：因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。



原码：原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制

​       [+1]原 = 0000 0001

​       [-1]原 = 1000 0001



反码：正数的反码是其本身,负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

​    [+1] = [00000001]原 = [00000001]反

​    [-1] = [10000001]原 = [11111110]反



补码：正数的补码就是其本身,负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补



计算机只做加法



反码出现的意义：解决计算机计算减法乘法是只做加法的问题。



补码出现的意义：在反码基础上解决-0和0 的问题



原码相加：

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2



反码相加：

1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0



虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.



补码相加：

1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原







&  :  二进制中 位数值都为1



| ：二进制中 位数值有一个为1，就为1



^ ：二进制中 位数值不相同，则为1







**<<表示左移移，不分正负数，低位补0；**　

注：以下数据类型默认为byte-8位

左移时不管正负，低位补0

正数：**r = 20 << 2**

　　20的二进制补码：**0001 0100**

　　向左移动两位后：**0101 0000**

　　　　   　　结果：**r = 80**

负数：**r = -20 << 2**

　　-20 的二进制原码 ：**1001 0100**

　　-20 的二进制反码 **：1110 1011**

　　-20 的二进制补码 ：**1110 1100**

　　左移两位后的补码：**1011 0000**

　　　　　　　　反码：**1010 1111**

　　　　　　　　原码：**1101 0000**

　　　　　　　　结果：**r = -80**

**>>表示右移，如果该数为正，则高位补0，若为负数，则高位补1；**

注：以下数据类型默认为byte-8位

正数：**r = 20 >> 2**

　　20的二进制补码：**0001 0100**

　　向右移动两位后：**0000 0101**

　　　　　　　结果：**r = 5**

负数：**r = -20 >> 2**

　　-20 的二进制原码 ：**1001 0100**

　　-20 的二进制反码 **：1110 1011**

　　-20 的二进制补码 ：**1110 1100** 

　　右移两位后的补码：**1111 1011** 

　　　　　　　　反码：**1111 1010**

　　　　　　　　原码：**1000 0101**

　　　　　　　　结果：**r = -5**

**>>>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0**

正数：　**r = 20 >>> 2**

　　　　的结果与 r = 20 >> 2 相同；

负数：　**r = -20 >>> 2**

注：以下数据类型默认为int 32位

　　-20:源码：**10000000 00000000 00000000 00010100**

　　　　反码：**11111111  11111111   11111111   11101011**

　　　　补码：**11111111  11111111   11111111   11101100**

　　　　右移：**00111111  11111111   11111111   11111011**

　　　　结果：**r = 1073741819**





java 基本类型占用字节数

|        | 字节   | 位     | 长度    | 范围           |
| ------ | ------ | ------ | ------- | -------------- |
| byte   | 1 byte | 8 bit  | 2^8=256 | (-2^7,2^7-1)   |
| char   | 2 byte | 16 bit | 2^16    | (-2^15,2^15-1) |
| int    | 4 byte | 32 bit | 2^32    | (-2^31,2^31-1) |
| short  | 2 byte | 16 bit | 2^16    | (-2^15,2^15-1) |
| long   | 8 byte | 64 bit | 2^64    | (-2^63,2^63-1) |
| double | 8 byte | 64 bit | 2^64    | (-2^63,2^63-1) |
| float  | 4 byte | 32 bit | 2^32    | (-2^31,2^31-1) |

