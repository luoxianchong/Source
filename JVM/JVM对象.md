## JVM对象

#### 对象的创建

对于new指令创建的对象：

​	1、检查常量池该类的符号引用

​	2、该类是否被类加载器加载（加载、验证、解析、准备、初始化）

​	3、分配内存，新生对象的内存大小是在类加载完成后即可确认的。

​		3.1、如果内存是规整的（即已使用内存在一边，空闲在另一边，中间边界有个指针指示器），分配新的内存时指针挪动新对象内存的大小。这种方式成为“指针碰撞”

​		3.2、如果不规整，则虚拟机维护一个空闲列表，记录那块内存是可用的，在分配新的内存时，找到一块足够大的空间划分给对象实例。

​		3.3、内存是否规整由java堆采用的垃圾收集是否带有压缩整理功能决定。

​	4、新建对象内存分配存在线程安全问题，比如：对象A分配完成指针为修改。对象B又使用了原来的指针分配对象

​		4.1、解决以上问题提供两种方案：①采用CAS加上失败重试方法保证原子操作；②使用本地线程分配缓冲（Thread Local Allocation Buffer ,TLAB）这是按照线程来划分的，哪个线程需要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁。

​	5、内存分配完成对象的内存空间初始化都为零（不包括对象头）。



#### 对象内存布局

​	内存分为3个区域：对象头、实例数据、对齐填充

​		一、 ```对象头``` 包括两部分信息：

​				①、用于存储对象自身的**运行时数据**，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳、对象分代年龄，这部分信息称为“Mark Word”

​				②、是**类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

对象处于未被锁定的状态下，那么 Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0

​			![](E:\201320180110\source\image\32BitMarkWork.png)



![数组](E:\201320180110\source\image\32bitMarkWork2.png)



#### 对象访问定位

1、使用句柄：

![](E:\201320180110\source\image\ObjecBar.png)

2、使用直接指针

![](E:\201320180110\source\image\directRef.png)





#### 对象进入老年代策略

1、大对象指的是需要分配大量连续内存空间的java对象

2、如果一个对象超过了-XX:PretenureSizeThreshold (默认值是：0，意思是不管多大都是先在eden中分配内存，该参数只对Serial和ParNew 收集器生效)参数所设置的值，该对象直接在老年代分配。

3、长期存活的对象进入老年代，对象每经过一次Minor GC，则改对象的年龄计算器（age）+1，当该数值大于等于-XX:MaxTenuringThreshold （默认：15）参数时则进入老年代。

4、如果Survivor空间中 相同年龄的对象 的大小总和大于Survivor空间的一半，则大于或等于该年龄的对象可以直接进来老年代，无须等到MaxTenuringThreshold中要求的年龄。

