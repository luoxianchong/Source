## GC

参数：-verbose:gc  和 -XX:+PrintGCDetails、-XX:+PrintGC

#### 一、如何判断为垃圾对象

##### 1、引用计数法

​		在对象中添加一个引用计数器：当被引用是就加1、失效时就减1、为0表示不再被使用。

​		主流jvm中并没有选用引用计数算法，原因很难解决对象之间的循环引用。

##### 2、可达性分析法

​		GC Roots

在Java语言中，可作为GC Roots的对象包含以下几种：

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象。
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中(Native方法)引用的对象

#### 二、如何回收

#### 1、回收策略

###### ①、标记-清除算法

​	根据可达性分析算法和第一次标记（能执行finalize()方法则执行。且只执行一次）、第二次清理来标记出存活对象和可回收对象。然后把可回收对象回收。

存在的问题：效率（效率低下）和空间问题（不会对回收后的内存进行整理）。

###### ②、复制算法

两块相同大小的内存，先把第一块内存中存活的对象复制到另一块内存中。再清空第一块内存。效率高，而空间消耗过大。通常使用在新生代，把Eden区和其中一个Survivor区中存活的对象复制到另一个Survivor区中。

###### ③、标记-整理算法

​	与标记清除算法相同、只是在后续中不是直接清理，而是让存活的对象向一端移动，然后直接清理掉端边界以外的内存。

###### ④、分代收集算法

​	商用虚拟机都采用分代收集算法。即结合前面两种（复制算法和标记整理算法）按照年代划分。新生代使用复制算法，因为存活量少。老年代使用标记整理算法。因为存活率高。

#### 2、垃圾收集器

​	2.1、Serial  单线程新生代收集器

​	2.2 、Serial old 单线程老年代收集器

​	2.3、ParNew  新生代多线程并行收集器

​	2.4、Parallel Scavenge  并行收集器，

​				特点：吞吐量优先，吞吐量=用户代码运行时间/(用户代码运行时间+垃圾收集时间)

​	2.5、Parallel old 

​	2.6、CMS

​	2.7、G1

​    2.8、ZGC

![](/home/ing/Documents/Source/image/jvm/gc.jpg)



#### 三、何时回收



Minor GC :从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC

Major GC：是清理老年代。

Full GC： 是清理整个堆空间—包括年轻代和老年代。



从新生代到老年代：

1、大对象（连续空间大于-XX:PretenureSizeThreshold，默认为0，意思是不管多大都是先在eden中分配内存，并且只对Serial和ParNew收集器有效）直接到老年代

2、对象中年龄计数器大于（-XX:MaxTenuringThreshold,默认15），对象在新生代每经过一次Minor GC后任然存活就加1。

3、如果在Surivor空间中相同年龄的对象大小的总和大于Survivior空间的一半，则年龄大于或等于该年龄的对象就可以直接进入老年代，无须等待到MaxTenuringThreshold.



Full GC 触发的条件：

在发生minor gc之前，虚拟机会检测 : 老年代最大可用的连续空间>新生代all对象总空间？

1、满足，minor gc是安全的，可以进行minor gc。

2、不满足，虚拟机查看HandlePromotionFailure参数：

​	（1）为true，允许担保失败，会继续检测老年代最大可用的连续空间>历次晋升到老年代对象的平均大小。若大于，将尝试进行一次minor gc，若失败，则重新进行一次full gc。

（2）为false，则不允许冒险，要进行full gc（对老年代进行gc）。            